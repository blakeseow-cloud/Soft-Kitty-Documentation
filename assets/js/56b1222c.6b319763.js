"use strict";(globalThis.webpackChunksoft_kitty_docs=globalThis.webpackChunksoft_kitty_docs||[]).push([[2944],{5826(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"master-combat-core/nodes/branch","title":"Branch Node","description":"Overview","source":"@site/docs/master-combat-core/nodes/branch.md","sourceDirName":"master-combat-core/nodes","slug":"/master-combat-core/nodes/branch","permalink":"/docs/master-combat-core/nodes/branch","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Branch Node"},"sidebar":"docs","previous":{"title":"Entity Node","permalink":"/docs/master-combat-core/nodes/entity"},"next":{"title":"Custom Node Tool","permalink":"/docs/master-combat-core/custom-node-tool"}}');var i=s(4848),r=s(8453);const c={title:"Branch Node"},t=void 0,d={},l=[{value:"Overview",id:"overview",level:3},{value:"Purpose",id:"purpose",level:3},{value:"Execution Behavior",id:"execution-behavior",level:3},{value:"Port Connection Rules",id:"port-connection-rules",level:3},{value:"Input Ports",id:"input-ports",level:4},{value:"Output Ports",id:"output-ports",level:4},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Design Philosophy",id:"design-philosophy",level:3},{value:"Summary",id:"summary",level:3}];function a(e){const n={a:"a",code:"code",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Branch Nodes"})," are flow-control nodes used to evaluate conditions and determine which execution path the graph should follow. They have a ",(0,i.jsx)(n.strong,{children:"True"})," input and a ",(0,i.jsx)(n.strong,{children:"False"})," input, along with a ",(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/condition",children:"condition"})," type input to determin whether forward the ",(0,i.jsx)(n.strong,{children:"True"})," input or ",(0,i.jsx)(n.strong,{children:"False"})," input."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Branch Nodes"})," enable conditional logic such as comparisons, checks, and rule evaluation within the graph system."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:s(6948).A+"",width:"1327",height:"588"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Branch Nodes"})," are used to:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Control execution flow based on conditions"}),"\n",(0,i.jsx)(n.li,{children:"Compare values and make decisions"}),"\n",(0,i.jsx)(n.li,{children:"Split execution paths dynamically"}),"\n",(0,i.jsx)(n.li,{children:"Gate Action Nodes behind logical rules"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"They are the primary mechanism for implementing if / else-style logic in the graph."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"execution-behavior",children:"Execution Behavior"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Branch Nodes"})," are evaluated when reached during graph execution."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"They read input values and evaluate a condition."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Based on the result, execution continues through the corresponding output port."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Branch Nodes"})," do not modify data directly."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"port-connection-rules",children:"Port Connection Rules"}),"\n",(0,i.jsx)(n.h4,{id:"input-ports",children:"Input Ports"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Condition Type Input Port"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Can connect from a ",(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/condition",children:"Condition Node"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"True/False Input Ports"}),"\r\n(Availability depends on the specific ",(0,i.jsx)(n.code,{children:"Branch Type"})," implementation)"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Can connect from ",(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/variable-math",children:"Variable Node"})]}),"\n",(0,i.jsxs)(n.li,{children:["Can connect from ",(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/variable-math",children:"Math Node"})]}),"\n",(0,i.jsxs)(n.li,{children:["Can connect from ",(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/entity",children:"Entity Node"})]}),"\n",(0,i.jsxs)(n.li,{children:["Can connect from a ",(0,i.jsx)(n.code,{children:"Root Node"})]}),"\n",(0,i.jsxs)(n.li,{children:["Can connect from another ",(0,i.jsx)(n.code,{children:"Branch Node"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These ports supply the data required to evaluate the branch condition."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h4,{id:"output-ports",children:"Output Ports"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Outputs"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Output ports represent possible evaluation results (for example, True / False)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Output port can connect to:\r\n(Availability depends on the specific ",(0,i.jsx)(n.code,{children:"Branch Type"})," implementation)"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"Branch Nodes"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/variable-math",children:"Variable Node"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/variable-math",children:"Math Node"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/action",children:"Action Node"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/condition",children:"Condition Node"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Execution continues through the output port that matches the evaluation result."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,i.jsxs)(n.p,{children:["Typical ",(0,i.jsx)(n.code,{children:"Branch Nodes"})," include:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"State or flag checks"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Cooldown or timing validation"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Custom rule evaluation"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Branch Nodes"})," are commonly placed between the ",(0,i.jsx)(n.code,{children:"Root Node"})," and ",(0,i.jsx)(n.a,{href:"/docs/master-combat-core/nodes/action",children:"Action Node"}),", or chained together to form complex decision logic."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Branch Nodes"})," focus exclusively on decision-making."]}),"\n",(0,i.jsx)(n.p,{children:"They:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Do not execute gameplay effects"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Do not modify backend data"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This separation improves readability, reusability, and maintainability of combat graphs."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Branch Nodes"})," evaluate conditions"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"They control execution flow"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"They do not produce gameplay effects"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"They direct execution toward Branch or Action Nodes"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},6948(e,n,s){s.d(n,{A:()=>o});const o=s.p+"assets/images/20260101-230119-287e7dd6972284d28b440495995dd4f2.png"},8453(e,n,s){s.d(n,{R:()=>c,x:()=>t});var o=s(6540);const i={},r=o.createContext(i);function c(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);