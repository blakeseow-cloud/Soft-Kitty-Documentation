"use strict";(globalThis.webpackChunksoft_kitty_docs=globalThis.webpackChunksoft_kitty_docs||[]).push([[7868],{2903(e,n,s){s.d(n,{A:()=>i});const i=s.p+"assets/images/20260142-224251-508b04b551ae001b0287d0df1d541d7d.png"},6658(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>a,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"master-combat-core/nodes/trigger","title":"Trigger Node","description":"Overview","source":"@site/docs/master-combat-core/nodes/trigger.md","sourceDirName":"master-combat-core/nodes","slug":"/master-combat-core/nodes/trigger","permalink":"/Soft-Kitty-Documentation/docs/master-combat-core/nodes/trigger","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Trigger Node"},"sidebar":"docs","previous":{"title":"Overview","permalink":"/Soft-Kitty-Documentation/docs/master-combat-core/nodes/overview"},"next":{"title":"Condition & Condition Group","permalink":"/Soft-Kitty-Documentation/docs/master-combat-core/nodes/condition"}}');var r=s(4848),o=s(8453);const t={title:"Trigger Node"},d=void 0,c={},l=[{value:"Overview",id:"overview",level:3},{value:"Purpose",id:"purpose",level:3},{value:"Execution Behavior",id:"execution-behavior",level:3},{value:"Port Connection Rules",id:"port-connection-rules",level:3},{value:"Input Ports",id:"input-ports",level:4},{value:"Output Ports",id:"output-ports",level:4},{value:"Root Node Interaction",id:"root-node-interaction",level:3},{value:"Reset Behavior",id:"reset-behavior",level:3},{value:"Auto Reset",id:"auto-reset",level:4},{value:"Manual Reset (Condition-Based)",id:"manual-reset-condition-based",level:4},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Design Philosophy",id:"design-philosophy",level:3},{value:"Summary",id:"summary",level:3}];function h(e){const n={a:"a",code:"code",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Nodes"})," are stateful gate nodes used to control when a graph is allowed to execute. They evaluate connected condition nodes and cache their result until explicitly reset."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Nodes"})," do not execute gameplay logic themselves. Instead, they determine whether connected ",(0,r.jsx)(n.code,{children:"Root Nodes"})," are allowed to run."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:s(2903).A+"",width:"819",height:"372"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsx)(n.p,{children:"Trigger Nodes are used to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Gate graph execution behind one or more conditions"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Cache condition results across graph calls"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Control one-time or persistent execution"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Provide precise control over when ",(0,r.jsx)(n.code,{children:"Root Nodes"})," activate"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"They are especially useful for implementing cooldowns, state-based triggers, and one-shot logic."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"execution-behavior",children:"Execution Behavior"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["When the graph is evaluated, the ",(0,r.jsx)(n.code,{children:"Trigger Node"})," checks all connected ",(0,r.jsx)(n.a,{href:"/docs/master-combat-core/nodes/condition",children:"condition-type nodes"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If all connected conditions evaluate to True, the ",(0,r.jsx)(n.code,{children:"Trigger Node"})," becomes triggered."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Once triggered, the result is cached and reused on subsequent graph evaluations."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The cached result remains valid until the ",(0,r.jsx)(n.code,{children:"Trigger Node"})," is reset."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Nodes"})," do not perform actions or control flow directly; they only determine whether execution may proceed."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"port-connection-rules",children:"Port Connection Rules"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.h4,{id:"input-ports",children:"Input Ports"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Input Port"})," can connect from:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"/docs/master-combat-core/nodes/condition",children:"Condition Node"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"/docs/master-combat-core/nodes/condition",children:"Condition Group Node"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Reset Input Port"})," can connect from:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"/docs/master-combat-core/nodes/condition",children:"Condition Node"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"/docs/master-combat-core/nodes/condition",children:"Condition Group Node"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger"})," conditions determine when the node becomes triggered.\r\n",(0,r.jsx)(n.code,{children:"Reset"})," conditions determine when the cached result is cleared."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.h4,{id:"output-ports",children:"Output Ports"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Output Port"})," can connect only to:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Root Nodes"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The output represents whether the ",(0,r.jsx)(n.code,{children:"Trigger Node"})," is currently in a triggered state."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"root-node-interaction",children:"Root Node Interaction"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"Root Node"})," may have multiple ",(0,r.jsx)(n.code,{children:"Trigger Nodes"})," connected to it."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Root Node"})," will execute only if all connected ",(0,r.jsx)(n.code,{children:"Trigger Nodes"})," evaluate to ",(0,r.jsx)(n.strong,{children:"True"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If any ",(0,r.jsx)(n.code,{children:"Trigger Node"})," is not triggered, the ",(0,r.jsx)(n.code,{children:"Root Node"})," will not execute."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This allows multiple independent trigger requirements to gate the same execution logic."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"reset-behavior",children:"Reset Behavior"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Nodes"})," support two reset mechanisms:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.h4,{id:"auto-reset",children:"Auto Reset"}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.strong,{children:"Auto Reset"})," is enabled:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The Trigger Node automatically resets after the connected ",(0,r.jsx)(n.code,{children:"Root Node"})," finishes execution."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The trigger conditions must be met again before execution can occur."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.h4,{id:"manual-reset-condition-based",children:"Manual Reset (Condition-Based)"}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.strong,{children:"Auto Reset"})," is disabled:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Trigger Node"})," retains its cached result."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The cached state remains until all connected reset conditions evaluate to ",(0,r.jsx)(n.strong,{children:"True"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This allows ",(0,r.jsx)(n.code,{children:"Trigger Nodes"})," to represent persistent or one-shot states."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,r.jsxs)(n.p,{children:["Typical ",(0,r.jsx)(n.code,{children:"Trigger Node"})," use cases include:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Cooldown-based activation"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"One-time combat or ability triggers"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"State-based execution gates"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Multi-condition activation logic"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Persistent unlocks or flags"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Nodes"})," are usually placed before ",(0,r.jsx)(n.code,{children:"Root Nodes"})," to explicitly define when execution is allowed."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Nodes"})," are designed to be:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Stateful (cache evaluation results)"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Deterministic (clear activation and reset rules)"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Composable (multiple triggers can gate one Root Node)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"By separating trigger logic from execution logic, graphs remain readable, predictable, and flexible."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trigger Nodes"})," gate ",(0,r.jsx)(n.code,{children:"Root Node"})," execution"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"They cache condition results"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["They only output to ",(0,r.jsx)(n.code,{children:"Root Nodes"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"They support auto and condition-based reset"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function a(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453(e,n,s){s.d(n,{R:()=>t,x:()=>d});var i=s(6540);const r={},o=i.createContext(r);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);